'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var anchorme = _interopDefault(require('anchorme'));

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

const APOSTROPHE = '\u02bc';
const TURNED_COMMA = '\u2018';
const LATIN_CHARACTERS = {
  ['A']: 'А',
  ['a']: 'а',
  ['B']: 'Б',
  ['b']: 'б',
  ['D']: 'Д',
  ['d']: 'д',
  ['E']: 'Е',
  ['e']: 'е',
  ['F']: 'Ф',
  ['f']: 'ф',
  ['G']: 'Г',
  ['g']: 'г',
  ['H']: 'Ҳ',
  ['h']: 'ҳ',
  ['I']: 'И',
  ['i']: 'и',
  ['J']: 'Ж',
  ['j']: 'ж',
  ['K']: 'К',
  ['k']: 'к',
  ['L']: 'Л',
  ['l']: 'л',
  ['M']: 'М',
  ['m']: 'м',
  ['N']: 'Н',
  ['n']: 'н',
  ['O']: 'О',
  ['o']: 'о',
  ['P']: 'П',
  ['p']: 'п',
  ['Q']: 'Қ',
  ['q']: 'қ',
  ['R']: 'Р',
  ['r']: 'р',
  ['S']: 'С',
  ['s']: 'с',
  ['T']: 'Т',
  ['t']: 'т',
  ['U']: 'У',
  ['u']: 'у',
  ['V']: 'В',
  ['v']: 'в',
  ['X']: 'Х',
  ['x']: 'х',
  ['Y']: 'Й',
  ['y']: 'й',
  ['Z']: 'З',
  ['z']: 'з'
};
const CYRILLIC_CHARACTERS = {
  ['А']: 'A',
  ['а']: 'a',
  ['Б']: 'B',
  ['б']: 'b',
  ['Д']: 'D',
  ['д']: 'd',
  ['Е']: 'E',
  ['е']: 'e',
  ['Ф']: 'F',
  ['ф']: 'f',
  ['Г']: 'G',
  ['г']: 'g',
  ['Ҳ']: 'H',
  ['ҳ']: 'h',
  ['И']: 'I',
  ['и']: 'i',
  ['Ж']: 'J',
  ['ж']: 'j',
  ['К']: 'K',
  ['к']: 'k',
  ['Л']: 'L',
  ['л']: 'l',
  ['М']: 'M',
  ['м']: 'm',
  ['Н']: 'N',
  ['н']: 'n',
  ['О']: 'O',
  ['о']: 'o',
  ['П']: 'P',
  ['п']: 'p',
  ['Қ']: 'Q',
  ['қ']: 'q',
  ['Р']: 'R',
  ['р']: 'r',
  ['С']: 'S',
  ['с']: 's',
  ['Т']: 'T',
  ['т']: 't',
  ['У']: 'U',
  ['у']: 'u',
  ['В']: 'V',
  ['в']: 'v',
  ['Х']: 'X',
  ['х']: 'x',
  ['Й']: 'Y',
  ['й']: 'y',
  ['З']: 'Z',
  ['з']: 'z',
  ['Ў']: `O${TURNED_COMMA}`,
  ['ў']: `o${TURNED_COMMA}`,
  ['Ғ']: `G${TURNED_COMMA}`,
  ['ғ']: `g${TURNED_COMMA}`,
  ['Ш']: 'Sh',
  ['ш']: 'sh',
  ['Ч']: 'Ch',
  ['ч']: 'ch',
  ['Ё']: 'Yo',
  ['ё']: 'yo',
  ['Ц']: 'S',
  ['ц']: 's',
  ['Ь']: '',
  ['ь']: '',
  ['Э']: 'E',
  ['э']: 'e',
  ['Ю']: 'Yu',
  ['ю']: 'yu',
  ['Я']: 'Ya',
  ['я']: 'ya',
  ['Ъ']: APOSTROPHE,
  ['ъ']: APOSTROPHE
};

function isLowerCase(char) {
  return char.toLowerCase() === char;
}
function normalizeCase(char, assimilateTo) {
  return isLowerCase(assimilateTo) ? char.toLowerCase() : char.toUpperCase();
}
function capitalize(word) {
  return word.charAt(0).toUpperCase() + word.substring(1).toLowerCase();
} // Detect only alphabetical letters, excluding apostrophe(')

function isLetter(char) {
  if (typeof char === 'string') {
    return /^[a-z\u0400-\u04FF]+$/i.test(char);
  }

  return false;
}
function isURL(word) {
  return anchorme.list(word).length > 0;
}
function escapeRegex(expString) {
  return expString.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
}
function endsWithSoftSign(word) {
  return /ь$/i.test(word);
}
function isRomanNumber(word) {
  return /^M{0,4}(CM|CD|D?C{0,3})(XC|XL|L?X{0,3})(IX|IV|V?I{0,3})(\.|\))?$/.test(word);
}

function normalizeBigramCasing(word, matcher, latinBigram) {
  return word.replace(matcher, (matchString, index) => {
    if (isLowerCase(matchString)) {
      return latinBigram.toLowerCase();
    }

    if (!isLetter(word[index - 1]) && !isLetter(word[index + 1])) {
      return capitalize(latinBigram);
    } // Assimilate to the next letter


    const assimilator = isLetter(word[index + 1]) && word[index + 1];

    if (assimilator) {
      return isLowerCase(assimilator) ? capitalize(latinBigram) : latinBigram.toUpperCase();
    }

    return latinBigram.toUpperCase();
  });
}

function replaceSpecials(word) {
  word = normalizeBigramCasing(word, /Ч/gi, 'CH');
  word = normalizeBigramCasing(word, /Ш/gi, 'SH');
  word = normalizeBigramCasing(word, /^Е/gi, 'YE');
  word = normalizeBigramCasing(word, /Ё/gi, 'YO');
  word = normalizeBigramCasing(word, /Ю/gi, 'YU');
  word = normalizeBigramCasing(word, /Я/gi, 'YA'); // Don't split into bigram if repetitive sequence of `e`s is 3+

  word = word.replace(/е{3,}/gi, matchString => matchString.replace(/е/gi, str => CYRILLIC_CHARACTERS[str] || str));
  return word.replace(/[ьъ]е/gi, str => normalizeCase('ye', str.charAt(1))).replace(/[аоэеиуўёюяaeiou]е/gi, str => str.charAt(0) + normalizeCase('ye', str.charAt(1))).replace(/ьо/gi, matchString => normalizeCase('yo', matchString.charAt(1))).replace(/[ўғ]ъ/gi, matchString => matchString.charAt(0)).replace(/[аоэеиуўёюяaeiou]ц/gi, str => str.charAt(0) + normalizeCase('ts', str.charAt(1)));
}

function cyrillicToLatin(word) {
  const escapedWord = replaceSpecials(word);
  let out = '';

  for (const char of escapedWord) {
    if (char in CYRILLIC_CHARACTERS) {
      out += CYRILLIC_CHARACTERS[char];
    } else {
      out += char;
    }
  }

  return out;
}

/*
  Exceptional word pairs works bidirectional even if
  transliteration from cyrillic to latin is usually
  possible without exceptions list. Sepatating list 
  into 2 (one for latin, the other for cyrillc) make
  things complicated. 
  
  Proposal can be introducing optional 3rd item to 
  `ExceptionalWordPair` which will indicate 
  bidirectional, only `latin->cyrillic` or only 
  `cyrillic->latin` transliteration. This way look-ups 
  in exceptionals list can be avoided where unecessary.
*/

class ExceptionalsCollection {
  constructor(exceptions = []) {
    _defineProperty(this, "collection", []);

    this.extend(exceptions);
  }

  extend(exceptions) {
    // TODO: Optimize for duplicates
    exceptions.forEach(pair => {
      if (pair && pair[0] && pair[1]) {
        this.collection.push(...this.generateWordCasingVariants(pair));
      }
    });
  }

  purge() {
    this.collection = [];
  }

  generateWordCasingVariants([latin, cyrillic]) {
    return [[latin.toLowerCase(), cyrillic.toLowerCase()], [latin.toUpperCase(), cyrillic.toUpperCase()], [capitalize(latin), capitalize(cyrillic)]];
  }

  getCase(exceptionalPair, source) {
    const exceptionSource = source === 'latin' ? 0 : 1;
    const exceptionTarget = source === 'latin' ? 1 : 0;
    return {
      exceptionalWord: exceptionalPair[exceptionSource],
      replacement: exceptionalPair[exceptionTarget]
    };
  }

  normalizeEndSoftSign(exceptional) {
    const {
      replacement
    } = exceptional;
    exceptional.replacement = replacement.substring(0, replacement.length - 1);
  }

  findInCollection(word, source) {
    let exceptional;
    let alternative; // If the word is typed with wrong letter-casing, default to lower-case or capitalize

    const shouldDefaultToLowerCase = isLowerCase(word.charAt(0));
    const altCasingMatch = shouldDefaultToLowerCase ? word.toLowerCase() : capitalize(word);

    for (const exceptionalPair of this.collection) {
      const {
        exceptionalWord,
        replacement
      } = this.getCase(exceptionalPair, source);

      if (word.startsWith(exceptionalWord)) {
        exceptional = {
          exceptionalWord,
          replacement
        };

        if (source === 'latin' && endsWithSoftSign(replacement) && word.length !== exceptionalWord.length) {
          this.normalizeEndSoftSign(exceptional);
        }

        return {
          exceptional
        };
      }

      if (altCasingMatch.startsWith(exceptionalWord)) {
        alternative = {
          exceptionalWord,
          replacement
        };
      }
    }

    return {
      alternative
    };
  }

  decideMatcher(exceptional, alternative) {
    if (exceptional !== undefined) {
      return exceptional.exceptionalWord;
    }

    if (alternative !== undefined) {
      // Using RegExp in "case-insensetive" mode to match exceptional
      // with its alternative casing
      return new RegExp(escapeRegex(alternative.exceptionalWord), 'gi');
    }
  }

  findCase(word, source) {
    const {
      exceptional,
      alternative
    } = this.findInCollection(word, source);
    const matcher = this.decideMatcher(exceptional, alternative);
    const replacement = (exceptional === null || exceptional === void 0 ? void 0 : exceptional.replacement) || (alternative === null || alternative === void 0 ? void 0 : alternative.replacement);

    if (matcher && replacement) {
      return {
        matcher,
        replacement
      };
    }
  }

}

function transliterateBigram(word, matcher, cyrillicBigram) {
  return word.replace(matcher, matchString => {
    return normalizeCase(cyrillicBigram, matchString[0]);
  });
}

function transliterateApostrophe(word) {
  const apostrophe = 'ъ';
  return word.replace(/[ʻʼ’'`‘´]/g, (_, index) => {
    // Prioritize assimilation to the next letter
    const assimilator = word[index + 1] || word[index - 1];

    if (assimilator) {
      return normalizeCase(apostrophe, assimilator);
    }

    return apostrophe.toLowerCase();
  });
}

function transliterateSpecialLetters(word) {
  word = word.replace(/tsi(on|ya)/gi, matchString => {
    return transliterateBigram(matchString, /ts/i, 'ц');
  });
  /* 
  Replace with 'Э' if:
    1. word starts with 'E'
    2. 'E' comes after non-letter symbol
    3. cyrillic letter 
  */

  word = word.replace(/^e|[\W]e/gi, matchString => {
    return transliterateBigram(matchString, /e/i, 'э');
  });
  word = word.replace(/e{2}/gi, matchString => {
    return matchString[0] + normalizeCase('э', matchString[1]);
  });
  word = transliterateBigram(word, /ch/gi, 'ч');
  word = transliterateBigram(word, /sh/gi, 'ш');
  word = transliterateBigram(word, /g[ʻʼ’'`‘´]/gi, 'ғ');
  word = transliterateBigram(word, /o[ʻʼ’'`‘´]/gi, 'ў');
  word = transliterateBigram(word, /ye/gi, 'е');
  word = transliterateBigram(word, /yo/gi, 'ё');
  word = transliterateBigram(word, /yu/gi, 'ю');
  word = transliterateBigram(word, /ya/gi, 'я'); // handle non-bigram "S'H" => "СҲ" combination

  word = word.replace(/s[ʻʼ’'`‘´]h/gi, matchString => {
    const s = LATIN_CHARACTERS[matchString[0]] || matchString[0];
    const h = LATIN_CHARACTERS[matchString[2]] || matchString[2];
    return s + h;
  });
  word = transliterateApostrophe(word);
  return word;
}

function latinToCyrillic(word) {
  const escapedWord = transliterateSpecialLetters(word);
  let out = '';

  for (const char of escapedWord) {
    if (char in LATIN_CHARACTERS) {
      out += LATIN_CHARACTERS[char];
    } else {
      out += char;
    }
  }

  return out;
}

class Transliterator {
  constructor(exceptions = []) {
    _defineProperty(this, "exceptionalsCollection", new ExceptionalsCollection());

    this.extendExceptionals(exceptions);
  }

  extendExceptionals(exceptions) {
    this.exceptionalsCollection.extend(exceptions);
  }

  purgeExceptionals() {
    this.exceptionalsCollection.purge();
  }

  getTransliterator(source) {
    return source === 'latin' ? latinToCyrillic : cyrillicToLatin;
  }

  replaceExceptionals(word, exceptional, replacement, transliterator) {
    let chunks = word.split(exceptional);
    chunks = chunks.map((chunk, i) => {
      const isLastChunk = i === chunks.length - 1;
      return transliterator(chunk) + (isLastChunk ? '' : replacement);
    });
    return chunks.join('');
  }

  handleExceptional(word, source) {
    const exceptional = this.exceptionalsCollection.findCase(word, source);

    if (exceptional) {
      return this.replaceExceptionals(word, exceptional.matcher, exceptional.replacement, this.getTransliterator(source));
    }
  }

  transliteratePureWord(word, source) {
    const transliterator = this.getTransliterator(source);
    return word.replace(/[ʻʼ’'`´‘a-z\u0400-\u04FF\-]+/gi, pureWord => {
      const exceptionalWord = this.handleExceptional(pureWord, source);

      if (exceptionalWord) {
        return exceptionalWord;
      }

      return transliterator(pureWord);
    });
  }

  transliterateWord(word, source) {
    if (isURL(word)) {
      return word;
    }

    if (isRomanNumber(word)) {
      return word;
    }

    const exceptionalWord = this.handleExceptional(word, source);

    if (exceptionalWord) {
      return exceptionalWord;
    }

    return this.transliteratePureWord(word, source);
  }

  toCyrillic(word) {
    if (word instanceof Array) {
      return word.map(w => this.transliterateWord(w, 'latin'));
    } else if (typeof word === 'string') {
      return this.transliterateWord(word, 'latin');
    }
  }

  toLatin(word) {
    if (word instanceof Array) {
      return word.map(w => this.transliterateWord(w, 'cyrillic'));
    } else if (typeof word === 'string') {
      return this.transliterateWord(word, 'cyrillic');
    }
  }

  textToCyrillic(text) {
    return text.replace(/\S+/g, word => this.transliterateWord(word, 'latin'));
  }

  textToLatin(text) {
    return text.replace(/\S+/g, word => this.transliterateWord(word, 'cyrillic'));
  }

}

exports.cyrillicToLatin = cyrillicToLatin;
exports.default = Transliterator;
exports.latinToCyrillic = latinToCyrillic;
//# sourceMappingURL=index.js.map
