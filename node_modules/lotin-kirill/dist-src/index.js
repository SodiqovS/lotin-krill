import { cyrillicToLatin } from "./cyrillic.js";
import { ExceptionalsCollection } from "./exceptionalsCollection.js";
import { latinToCyrillic } from "./latin.js";
import { isRomanNumber, isURL } from "./utils.js";
export default class Transliterator {
  exceptionalsCollection = new ExceptionalsCollection();

  constructor(exceptions = []) {
    this.extendExceptionals(exceptions);
  }

  extendExceptionals(exceptions) {
    this.exceptionalsCollection.extend(exceptions);
  }

  purgeExceptionals() {
    this.exceptionalsCollection.purge();
  }

  getTransliterator(source) {
    return source === 'latin' ? latinToCyrillic : cyrillicToLatin;
  }

  replaceExceptionals(word, exceptional, replacement, transliterator) {
    let chunks = word.split(exceptional);
    chunks = chunks.map((chunk, i) => {
      const isLastChunk = i === chunks.length - 1;
      return transliterator(chunk) + (isLastChunk ? '' : replacement);
    });
    return chunks.join('');
  }

  handleExceptional(word, source) {
    const exceptional = this.exceptionalsCollection.findCase(word, source);

    if (exceptional) {
      return this.replaceExceptionals(word, exceptional.matcher, exceptional.replacement, this.getTransliterator(source));
    }
  }

  transliteratePureWord(word, source) {
    const transliterator = this.getTransliterator(source);
    return word.replace(/[ʻʼ’'`´‘a-z\u0400-\u04FF\-]+/gi, pureWord => {
      const exceptionalWord = this.handleExceptional(pureWord, source);

      if (exceptionalWord) {
        return exceptionalWord;
      }

      return transliterator(pureWord);
    });
  }

  transliterateWord(word, source) {
    if (isURL(word)) {
      return word;
    }

    if (isRomanNumber(word)) {
      return word;
    }

    const exceptionalWord = this.handleExceptional(word, source);

    if (exceptionalWord) {
      return exceptionalWord;
    }

    return this.transliteratePureWord(word, source);
  }

  toCyrillic(word) {
    if (word instanceof Array) {
      return word.map(w => this.transliterateWord(w, 'latin'));
    } else if (typeof word === 'string') {
      return this.transliterateWord(word, 'latin');
    }
  }

  toLatin(word) {
    if (word instanceof Array) {
      return word.map(w => this.transliterateWord(w, 'cyrillic'));
    } else if (typeof word === 'string') {
      return this.transliterateWord(word, 'cyrillic');
    }
  }

  textToCyrillic(text) {
    return text.replace(/\S+/g, word => this.transliterateWord(word, 'latin'));
  }

  textToLatin(text) {
    return text.replace(/\S+/g, word => this.transliterateWord(word, 'cyrillic'));
  }

}
export { cyrillicToLatin, latinToCyrillic };