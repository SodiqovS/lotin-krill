import { capitalize, endsWithSoftSign, escapeRegex, isLowerCase } from "./utils.js";
/*
  Exceptional word pairs works bidirectional even if
  transliteration from cyrillic to latin is usually
  possible without exceptions list. Sepatating list 
  into 2 (one for latin, the other for cyrillc) make
  things complicated. 
  
  Proposal can be introducing optional 3rd item to 
  `ExceptionalWordPair` which will indicate 
  bidirectional, only `latin->cyrillic` or only 
  `cyrillic->latin` transliteration. This way look-ups 
  in exceptionals list can be avoided where unecessary.
*/

export class ExceptionalsCollection {
  collection = [];

  constructor(exceptions = []) {
    this.extend(exceptions);
  }

  extend(exceptions) {
    // TODO: Optimize for duplicates
    exceptions.forEach(pair => {
      if (pair && pair[0] && pair[1]) {
        this.collection.push(...this.generateWordCasingVariants(pair));
      }
    });
  }

  purge() {
    this.collection = [];
  }

  generateWordCasingVariants([latin, cyrillic]) {
    return [[latin.toLowerCase(), cyrillic.toLowerCase()], [latin.toUpperCase(), cyrillic.toUpperCase()], [capitalize(latin), capitalize(cyrillic)]];
  }

  getCase(exceptionalPair, source) {
    const exceptionSource = source === 'latin' ? 0 : 1;
    const exceptionTarget = source === 'latin' ? 1 : 0;
    return {
      exceptionalWord: exceptionalPair[exceptionSource],
      replacement: exceptionalPair[exceptionTarget]
    };
  }

  normalizeEndSoftSign(exceptional) {
    const {
      replacement
    } = exceptional;
    exceptional.replacement = replacement.substring(0, replacement.length - 1);
  }

  findInCollection(word, source) {
    let exceptional;
    let alternative; // If the word is typed with wrong letter-casing, default to lower-case or capitalize

    const shouldDefaultToLowerCase = isLowerCase(word.charAt(0));
    const altCasingMatch = shouldDefaultToLowerCase ? word.toLowerCase() : capitalize(word);

    for (const exceptionalPair of this.collection) {
      const {
        exceptionalWord,
        replacement
      } = this.getCase(exceptionalPair, source);

      if (word.startsWith(exceptionalWord)) {
        exceptional = {
          exceptionalWord,
          replacement
        };

        if (source === 'latin' && endsWithSoftSign(replacement) && word.length !== exceptionalWord.length) {
          this.normalizeEndSoftSign(exceptional);
        }

        return {
          exceptional
        };
      }

      if (altCasingMatch.startsWith(exceptionalWord)) {
        alternative = {
          exceptionalWord,
          replacement
        };
      }
    }

    return {
      alternative
    };
  }

  decideMatcher(exceptional, alternative) {
    if (exceptional !== undefined) {
      return exceptional.exceptionalWord;
    }

    if (alternative !== undefined) {
      // Using RegExp in "case-insensetive" mode to match exceptional
      // with its alternative casing
      return new RegExp(escapeRegex(alternative.exceptionalWord), 'gi');
    }
  }

  findCase(word, source) {
    const {
      exceptional,
      alternative
    } = this.findInCollection(word, source);
    const matcher = this.decideMatcher(exceptional, alternative);
    const replacement = exceptional?.replacement || alternative?.replacement;

    if (matcher && replacement) {
      return {
        matcher,
        replacement
      };
    }
  }

}